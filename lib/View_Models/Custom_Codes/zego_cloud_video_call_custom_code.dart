import 'package:chatty/View_Models/Blocs/Zego_Cloud_Blocs/Video_Call_Blocs/Create_Local_User_View_Id_Bloc/create_local_user_view_id_bloc.dart';
import 'package:chatty/View_Models/Blocs/Zego_Cloud_Blocs/Video_Call_Blocs/Create_Local_User_Widget_For_Start_Preview_Bloc/create_local_user_user_widget_for_start_preview_bloc.dart';
import 'package:chatty/View_Models/Blocs/Zego_Cloud_Blocs/Video_Call_Blocs/Create_Remote_User_Preview_Bloc/create_remote_user_view_bloc.dart';
import 'package:chatty/View_Models/Blocs/Zego_Cloud_Blocs/Video_Call_Blocs/Create_Remote_User_View_Id_Bloc/create_remote_user_view_id_bloc.dart';
import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:zego_express_engine/zego_express_engine.dart';

const appID = 1517302870;
const appSign =
    "4fe6324b9054158dea7d4df97b56867a9857269e25384c8f62943311ba9cc092";
const serverSecret = "6bce6bc691107d8724e56ebc00166f81";

Future<void> createEngine() async {
  WidgetsFlutterBinding.ensureInitialized();
  // Get your AppID and AppSign from ZEGOCLOUD Console
  //[My Projects -> AppID] : https://console.zegocloud.com/project
  await ZegoExpressEngine.createEngineWithProfile(ZegoEngineProfile(
    appID,
    ZegoScenario.Default,
    appSign: kIsWeb ? null : appSign,
  ));
}

Future<ZegoRoomLoginResult> loginRoom(
    {required BuildContext context,
    required String localUserID,
    required String localUserName,
    required String roomId,
    required int? localViewID}) async {
  // The value of `userID` is generated locally and must be globally unique.
  final user = ZegoUser(localUserID, localUserName);

  // The value of `roomID` is generated locally and must be globally unique.
  final roomID = roomId;

  // onRoomUserUpdate callback can be received when "isUserStatusNotify" parameter value is "true".
  ZegoRoomConfig roomConfig = ZegoRoomConfig.defaultConfig()
    ..isUserStatusNotify = true;

  // if (kIsWeb) {
  //   // ! ** Warning: ZegoTokenUtils is only for use during testing. When your application goes live,
  //   // ! ** tokens must be generated by the server side. Please do not generate tokens on the client side!
  //   roomConfig.token =
  //       ZegoTokenUtils.generateToken(appID, serverSecret, widget.localUserID);
  // }
  // log in to a room
  // Users must log in to the same room to call each other.
  return ZegoExpressEngine.instance
      .loginRoom(roomID, user, config: roomConfig)
      .then((ZegoRoomLoginResult loginRoomResult) {
    debugPrint(
        'loginRoom: errorCode:${loginRoomResult.errorCode}, extendedData:${loginRoomResult.extendedData}');
    if (loginRoomResult.errorCode == 0) {
      startPreview(context: context, localViewID: localViewID);
      startPublish(localUserID: localUserID, roomId: roomID);
    } else {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(
          content: Text('loginRoom failed: ${loginRoomResult.errorCode}')));
    }
    return loginRoomResult;
  });
}

Future<ZegoRoomLogoutResult> logoutRoom(
    {required BuildContext context,
    int? localViewID,
    required String? roomID}) async {
  stopPreview(context: context, localViewID: localViewID);
  stopPublish();
  return ZegoExpressEngine.instance.logoutRoom(roomID: roomID);
}

void startListenEvent(
    {required BuildContext context, required int? remoteViewID}) {
  // Callback for updates on the status of other users in the room.
  // Users can only receive callbacks when the isUserStatusNotify property of ZegoRoomConfig is set to `true` when logging in to the room (loginRoom).
  ZegoExpressEngine.onRoomUserUpdate =
      (roomID, updateType, List<ZegoUser> userList) {
    debugPrint(
        'onRoomUserUpdate: roomID: $roomID, updateType: ${updateType.name}, userList: ${userList.map((e) => e.userID)}');
  };
  // Callback for updates on the status of the streams in the room.
  ZegoExpressEngine.onRoomStreamUpdate =
      (roomID, updateType, List<ZegoStream> streamList, extendedData) {
    debugPrint(
        'onRoomStreamUpdate: roomID: $roomID, updateType: $updateType, streamList: ${streamList.map((e) => e.streamID)}, extendedData: $extendedData');
    if (updateType == ZegoUpdateType.Add) {
      for (final stream in streamList) {
        startPlayStream(
            streamID: stream.streamID,
            context: context,
            remoteViewID: remoteViewID);
      }
    } else {
      for (final stream in streamList) {
        stopPlayStream(
            streamID: stream.streamID,
            context: context,
            remoteViewID: remoteViewID);
      }
    }
  };
  // Callback for updates on the current user's room connection status.
  ZegoExpressEngine.onRoomStateUpdate =
      (roomID, state, errorCode, extendedData) {
    debugPrint(
        'onRoomStateUpdate: roomID: $roomID, state: ${state.name}, errorCode: $errorCode, extendedData: $extendedData');
  };

  // Callback for updates on the current user's stream publishing changes.
  ZegoExpressEngine.onPublisherStateUpdate =
      (streamID, state, errorCode, extendedData) {
    debugPrint(
        'onPublisherStateUpdate: streamID: $streamID, state: ${state.name}, errorCode: $errorCode, extendedData: $extendedData');
  };
}

void stopListenEvent() {
  ZegoExpressEngine.onRoomUserUpdate = null;
  ZegoExpressEngine.onRoomStreamUpdate = null;
  ZegoExpressEngine.onRoomStateUpdate = null;
  ZegoExpressEngine.onPublisherStateUpdate = null;
}

Future<void> startPreview(
    {required int? localViewID, required BuildContext context}) async {
  await ZegoExpressEngine.instance.createCanvasView((viewID) {
    localViewID = viewID;
    ZegoCanvas previewCanvas =
        ZegoCanvas(viewID, viewMode: ZegoViewMode.AspectFill);
    ZegoExpressEngine.instance.startPreview(canvas: previewCanvas);
  }).then((canvasViewWidget) {
    // setState(() => localView = canvasViewWidget);
    context.read<CreateLocalUserWidgetForStartPreviewBloc>().add(
        CreateLocalUserWidgetForStartPreviewFromGivenZegoCreatedWidgetEvent(
            zegoCreatedWidget: canvasViewWidget));
  });
}

Future<void> stopPreview(
    {required int? localViewID, required BuildContext context}) async {
  ZegoExpressEngine.instance.stopPreview();
  if (localViewID != null) {
    await ZegoExpressEngine.instance.destroyCanvasView(localViewID!);
    // localViewID = null;
    context
        .read<CreateLocalUserViewIdBloc>()
        .add(const CreateLocalUserViewIdFromZegoCloud(localUserViewId: null));
    // localView = null;
    context.read<CreateLocalUserWidgetForStartPreviewBloc>().add(
        const CreateLocalUserWidgetForStartPreviewFromGivenZegoCreatedWidgetEvent(
            zegoCreatedWidget: null));
  }
}

Future<void> startPublish(
    {required String roomId, required String localUserID}) async {
  // After calling the `loginRoom` method, call this method to publish streams.
  // The StreamID must be unique in the room.
  String streamID = '${roomId}_${localUserID}_call';
  return ZegoExpressEngine.instance.startPublishingStream(streamID);
}

Future<void> stopPublish() async {
  return ZegoExpressEngine.instance.stopPublishingStream();
}

Future<void> startPlayStream(
    {required String streamID,
    required BuildContext context,
    required int? remoteViewID}) async {
  // Start to play streams. Set the view for rendering the remote streams.
  await ZegoExpressEngine.instance.createCanvasView((viewID) {
    remoteViewID = viewID;
    ZegoCanvas canvas = ZegoCanvas(viewID, viewMode: ZegoViewMode.AspectFill);
    ZegoExpressEngine.instance.startPlayingStream(streamID, canvas: canvas);
  }).then((canvasViewWidget) {
    // setState(() => remoteView = canvasViewWidget);
    context.read<CreateRemoteUserViewBloc>().add(
        CreateRemoteUserWidgetFromGivenZegoCloudWidgetEvent(
            zegoCloudCreateWidget: canvasViewWidget));
  });
}

Future<void> stopPlayStream(
    {required String streamID,
    required BuildContext context,
    required int? remoteViewID}) async {
  ZegoExpressEngine.instance.stopPlayingStream(streamID);
  if (remoteViewID != null) {
    ZegoExpressEngine.instance.destroyCanvasView(remoteViewID);
    // remoteViewID = null;
    context.read<CreateRemoteUserViewIdBloc>().add(
        const CreateRemoteUserViewIdFromZegoCloudEvent(remoteUserViewId: null));
    // remoteView = null;
    context.read<CreateRemoteUserViewBloc>().add(
        const CreateRemoteUserWidgetFromGivenZegoCloudWidgetEvent(
            zegoCloudCreateWidget: null));
  }
}
